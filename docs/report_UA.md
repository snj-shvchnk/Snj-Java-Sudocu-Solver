# Розробка Snj-Sudocu-Solver

## Задача:
Визначити, реалізувати та протестуєте розв’язувач судоку.
Використати мову програмування Java, протестувати за допомогою доданих матриць.
Написати документ про архітектуру, пояснити вибір та способи вирішення задачі.

![Snj-CSV-File-Reader](https://github.com/snj-shvchnk/Snj-Java-Sudocu-Solver/blob/master/docs/screen_java_debug.jpg.jpg?raw=true)

## Підготовка:

### Пошук інформації
	
Було проведене поверхневе R&D що до наявних рішень вирішення судоку методами програмного обчислення. Зокрема, були переглянуті варіанти розв'язання задачі за допомогою лінійних алгоритмів, Backtracking, Dancing Links, Algorithm X та інших.
Було визначєно, що людство вже має чималий досвід вирішення подібних задач, і може робити це багатьма способами.

### Вибір алгоритму
Так як з Судоку я стикнувся вперше, було вирішено реалізовувати інтуітивно зрозумілий алгоритм, який я застосовував при вирішенні Судоку без програмних засобів.
Також, це був мій перший досвід роботи з Java, і така форма реалізації дозволила мені познайомитися і попрацювати з базовими, і так добре знайомими з інших мов програмування, засобами ООП та лінійного програмування в новому програмному середовищі.

## Архітектура:

Дивлячись на структуру задачі, мені спало на думку, що пошук рішення є задачєю рекурсивного типу, коли ми занурюємося у верогідну версію матриці, шукаючи наступні рішення, і виходимо з гілки, якщо бачимо, що за наявних даних вирішити матрицю неможливо.

###  Алгоритм
То ж, вирішення полягє в рекурсивному виклику функції, що насагається підібрати корректні значення усіх порожніх клітинок, і звітує до викликавшого скоупу, чи вдалося знайти задовільне рішення при усіх вхідних умовах.
Структурно, етапи обробки кожної ітерації можна визначити так:

- Проход по матриці зліва направо зверху вниз
- Перевірка поточної координати на кінець матриці
- Перевірка поточної координати на кінець рядка
- Пошук задовільної відповіді
    - Перебирання значень 1-10
        - Перевірка на відповідність умов матриці
            - Перевірка унікальності в рядку
            - Перевірка унікальності в стовбці
            - Перевірка унікальності в межах локального кластера
- Перевірка наявності задовільняючого значення
- Визначення неможливості вірішення за наявних умов

### Графічне відображення алгоритму

![Snj-CSV-File-Reader](https://github.com/snj-shvchnk/Snj-Java-Sudocu-Solver/blob/master/docs/sudocu_algoritm.jpg.jpg?raw=true)

## Структура програми
При невеликому обсязі, вирішено обмежетись однією директорією і декількома класами, що містять логіку і налаштування програми.

- Головний клас App.java
    - Функція main - головна точка входу для запуска програми, розташував там початкові дані і виклик функції вирішення.
    - Функція _solveGrid - Обробляє один массив вхідних даних, власне - умову Судоку, і звітує до консолі про хід виконання вирішення, бо консоль - це хоч і низькорівневий, але Developer-friendly інтерфейс.

- Логічний клас Sudocu.java
    - Публічна точка входу ProcessGrid - викликається з керуючого коду програми, запускає рекурсію та є перевизначенням внутрішнього методу по обробці клітинки, зафіксований по координаті [0,0] - початок матриці.
    - Приватний рекурсивний метод _processGrid
    Обробляє перехід по клітинках, підбирає значення для порожніх клітинок, запускає перевірку валідності та звітує про можливість/неможливість підбору задовільного значення.

- Конфігурація Const.java
    Зберігає значення, необхідні для загального використання - розміри матриці і кластера. Є імплементацією конфігурації застосунка.

- Фукціональний клас Utils.java
    Набір функціоналу для обробки масиву, виводу на консоль, та (потенційно) інших методів, придатних до перевикористання.

## Реалізація

### Оточення для розробки
Були вжиті необхідні заходи для налаштування JAVA Development-Enviropment для моєї машини, вибір був зроблений на користь IDE Visual Studio Code та розширення Coding Pack for Java, з їх інтегрованим компілятором та синтаксичним аналізатором.
Виявилося, що з запуском JAVA усе набагато кращє, аніж мені чулося, після встановлення необхідних компонент, розробка проходила без значних перепон.
Посилання на мануал по облаштуванню Development-Enviropment:
https://code.visualstudio.com/docs/languages/java

### Проблеми та задачі
		
#### Знайомство з JAVA
Довелося ознайомитись з особливостями синтаксису та побудови віртуальної структури, врешті було визначено, що JAVA катастрофічно нагадує C#, і мій рівень розуміння ООП дозволив швидко облаштувати усі необхідні класи та методи.

#### Клонування массиву
В процесі стикнувся з типовою для високорівневих мов програмування проблемою - передаючі значення вхідного двовимірного масиву за посилянням, я не мав змоги наприкінці рішення вивести на консоль і умову, і рішення.
Задачєю стала реалізація метода по клонуванню двухвимірного массиву за значеннями, уникаючи посилань на об'єкт, бо саме двовимірність заважала скористатися вбудованою вункцією Array.Clone - хост-массив копіювався корректно, але внутрішні массиви-члени_множини передавались за посиланням і змінювалися в процесі рішення.
Імплементувавши метод копіювання дворівневого масиву, все запрацювало файно, проблеми зникли.

## Інструкція для запуску проекту:

### Development:
- Облаштувати оточення за інструкцією: https://code.visualstudio.com/docs/languages/java
- Клонувати репозиторій за посиланням:
https://github.com/snj-shvchnk/Snj-Java-Sudocu-Solver.git
- Запустити Visual Studio Code в корньовому каталозі
- Запустити проект і перейти в консоль для спостерігання результату.
- DONE!

### Distribution
- Відкрити термінал у корньовому каталозі проекту
- Запустити зкомпільовану версію програми за допомого команди:
        
        java -jar .\SnjSudocuSolver.jar

### Тестування

Проект було протестовано з двома прикладами з тестового завдання, легким і нормальним.
З обома програма впоралася, за 24ms і 40ms відповідно.

Також було написано умову Судоку, яка остаточно не має кінцевого вирішення. Програма видала корректний результат, витративши на це 8ms.

Також, поки я займався тестовим завданням, син зацікавився питанням і став вирішувати Судоку з інтернету поруч зі мною. У якості демонстрації потужності інтелектуальних здібностей та переваг Об'єктно Орієнтованої парадигми мислення, один з його прикладів також було внесено в програму і остаточно вирішено за 16ms.

Тестування вважаю вдалим, а результат що до швидкості - задовільним для поставленої задачі.